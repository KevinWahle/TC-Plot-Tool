# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'HWindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets

from src.ui.widgets.H_Window_design import H_Window_design
# from H_Window_design import H_Window_design


class H_Window(QtWidgets.QDialog, H_Window_design):

    def __init__(self, ureg, *args, **kargs) -> None:
        super().__init__(*args, **kargs)

        self.setupUi(self)

        # Expresion regular para tomar valores validos de numeros decimales separados por comas (punto separador decimal)
        # Se usa para validar que la entrada sea valida, por eso no puede terminar con ',' o con un numero incompleto ni vacio
        regexVal = QtGui.QRegExpValidator(QtCore.QRegExp("((\+|-)?\d+\.?\d*((e|E)(\+|-)?\d+)?($|,(?!$)))+"))

        self.numeradorT.setValidator(regexVal)
        self.denominadorT.setValidator(regexVal)
        self.freqMinT.setValidator(regexVal)
        self.freqMaxT.setValidator(regexVal)

        self.numeradorT.textChanged.connect(self.updateTF)
        self.denominadorT.textChanged.connect(self.updateTF)

        self.widgetTransferencia.setText('$H(s) =$')
        self.tfOk = False

        self.okBtn.clicked.connect(self.okBtnClick)

        # Valores de retorno
        self.name = ''      # Nombre de la curva
        self.numArr = []    # Arreglo de coeficientes del numerador
        self.denArr = []    # Arreglo de coeficientes del denominador
        self.freqRange = [float(self.freqMinT.placeholderText()), float(self.freqMaxT.placeholderText())] # Rango de frecuencias
        self.freqUnits = ureg.rps
        self.logscale = self.scaleLogRbtn.isChecked()   # Tipo de escala


    def okBtnClick(self):
        self.name = self.nombreT.text()

        self.removeLeadingZeros(self.numArr)
        self.removeLeadingZeros(self.denArr)

        self.logscale = self.scaleLogRbtn.isChecked()
        
        if not self.freqMinT.text():                                       # No hay nada, tomo el hint
            self.freqRange[0] = float(self.freqMinT.placeholderText())
        elif self.freqMinT.hasAcceptableInput():                       # Entrada valida, tomo el valor
            self.freqRange[0] = float(self.freqMinT.text())
        else:                                                          # Entrada invalida, no hago nada
            return
        
        if not self.freqMaxT.text():                                       # No hay nada, tomo el hint
            self.freqRange[1] = float(self.freqMaxT.placeholderText())
        elif self.freqMaxT.hasAcceptableInput():                       # Entrada valida, tomo el valor
            self.freqRange[1] = float(self.freqMaxT.text())
        else:                                                          # Entrada invalida, no hago nada
            return

        if self.name and self.numeradorT.hasAcceptableInput() and self.denominadorT.hasAcceptableInput() and self.tfOk \
        and self.numArr and self.denArr:            # H valida
        # and len(self.denArr) >= len(self.numArr): # H causal
            self.accept()


    def updateTF(self):
        num = self.numeradorT.text()
        den = self.denominadorT.text()

        if num and den:
            try:
                # Lo convierto en arreglo de floats, omitiendo si hay numeros incompletos
                self.numArr = [float(i) for i in list(filter(None, num.split(',')))]
                self.denArr = [float(i) for i in list(filter(None, den.split(',')))]

                num = self.arrToPol(self.numArr)
                den = self.arrToPol(self.denArr)

                self.widgetTransferencia.setText("$H(s) = \\frac{" + num + "}{" + den + "}$" )
                self.tfOk = True
            except:
                self.tfOk = False
        else:
            self.widgetTransferencia.setText("$H(s) =$")

    def removeLeadingZeros(self, arr):
            while len(arr) > 0 and arr[0] == 0:
                arr.pop(0)

    # Convierte un arreglo de numeros en un polinomio de s
    def arrToPol(self, arr = [], var = 's'):
        pol = ''
        for i in range(len(arr)):
            q = len(arr)-i-1
            if arr[i] != 0:
                if pol and arr[i] > 0:  # No es el primer elemento y es positivo
                    pol += ' + '

                if abs(arr[i]) != 1 or q<1:
                    base, exp = self.toBaseExp(arr[i])
                    if (exp < -1 or exp > 3):      # Numeros muy grandes o muy chicos los muestro en notacion cienifica
                        pol += str(base) + '\\times10^{'+str(exp)+'}\ '
                    else:
                        pol += "{:.2f}".format(arr[i]) + '\ '
                elif arr[i] == -1:
                    pol += '-'

                if  q > 1:
                    pol +=  var + '^{' + str(q) + '}'
                elif q==1:
                    pol += var

        return pol if pol else '0'

    def toBaseExp(self, num):
        str = "{:.2e}".format(num)
        return (float(str[:4]), int(str[-3:]))  # Tomo base y exponente del numero


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    ui = H_Window()
    ui.show()
    sys.exit(app.exec_())
